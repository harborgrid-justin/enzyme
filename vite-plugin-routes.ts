/**
 * @file Vite Plugin for Route Auto-Discovery
 * @description Build-time route discovery, conflict detection, and code generation
 */

import type { Plugin, ViteDevServer, ResolvedConfig } from 'vite';
import { resolve, dirname } from 'path';
import { writeFile, mkdir } from 'fs/promises';

import type { DiscoveryConfig, DiscoveredRoute } from './src/lib/routing/types';
import { DEFAULT_DISCOVERY_CONFIG } from './src/lib/routing/types';
import { scanRouteFiles, clearRouteCache, generateRouteId } from './src/lib/routing/scanner';
import { detectRouteConflicts, validateRoutes } from './src/lib/routing/conflict-detector';

// =============================================================================
// Plugin Options
// =============================================================================

export interface RouteDiscoveryPluginOptions {
  /** Discovery configuration overrides */
  config?: Partial<DiscoveryConfig>;

  /** Output directory for generated files (relative to project root) */
  outputDir?: string;

  /** Enable verbose logging */
  verbose?: boolean;

  /** Fail build on route conflicts (errors only) */
  failOnConflict?: boolean;

  /** Watch for file changes in dev mode */
  watch?: boolean;

  /** Generate TypeScript types */
  generateTypes?: boolean;

  /** Generate route registry */
  generateRegistry?: boolean;
}

// =============================================================================
// Code Generation
// =============================================================================

/**
 * Generate TypeScript type definitions for discovered routes
 */
function generateRouteTypes(routes: DiscoveredRoute[], rootDir: string): string {
  const lines: string[] = [
    '/**',
    ' * @file Auto-Generated Route Types',
    ' * @description DO NOT EDIT - Generated by vite-plugin-routes',
    ` * @generated ${new Date().toISOString()}`,
    ' */',
    '',
    '// =============================================================================',
    '// Route Path Constants',
    '// =============================================================================',
    '',
    'export const ROUTE_PATHS = {',
  ];

  const nonLayoutRoutes = routes.filter((r) => !r.isLayout);

  for (const route of nonLayoutRoutes) {
    const id = generateRouteId(route);
    lines.push(`  ${id}: '${route.urlPath}' as const,`);
  }

  lines.push('} as const;');
  lines.push('');
  lines.push('export type RouteId = keyof typeof ROUTE_PATHS;');
  lines.push('export type RoutePath = typeof ROUTE_PATHS[RouteId];');
  lines.push('');

  // Generate RouteParams interface
  lines.push('// =============================================================================');
  lines.push('// Route Parameter Types');
  lines.push('// =============================================================================');
  lines.push('');
  lines.push('export interface RouteParams {');

  for (const route of nonLayoutRoutes) {
    const paramMatches = route.urlPath.match(/:[^/?]+/g);
    if (paramMatches && paramMatches.length > 0) {
      const paramType = paramMatches
        .map((p) => {
          const name = p.slice(1).replace('?', '');
          const isOptional = p.includes('?');
          return isOptional ? `${name}?: string` : `${name}: string`;
        })
        .join('; ');
      lines.push(`  '${route.urlPath}': { ${paramType} };`);
    }
  }

  lines.push('}');
  lines.push('');

  // Generate type helpers
  lines.push('// =============================================================================');
  lines.push('// Type Helpers');
  lines.push('// =============================================================================');
  lines.push('');
  lines.push('/** Check if a path has parameters */');
  lines.push('export type HasParams<T extends RoutePath> = T extends keyof RouteParams ? true : false;');
  lines.push('');
  lines.push('/** Get params type for a path */');
  lines.push('export type ParamsFor<T extends RoutePath> = T extends keyof RouteParams');
  lines.push('  ? RouteParams[T]');
  lines.push('  : Record<string, never>;');
  lines.push('');

  return lines.join('\n');
}

/**
 * Generate route registry with lazy imports
 */
function generateRouteRegistry(routes: DiscoveredRoute[], rootDir: string): string {
  const lines: string[] = [
    '/**',
    ' * @file Auto-Generated Route Registry',
    ' * @description DO NOT EDIT - Generated by vite-plugin-routes',
    ` * @generated ${new Date().toISOString()}`,
    ' */',
    '',
    "import { lazy, type ComponentType, type LazyExoticComponent } from 'react';",
    "import { ROUTE_PATHS, type RouteParams } from './types';",
    '',
    '// =============================================================================',
    '// Path Builder',
    '// =============================================================================',
    '',
    '/**',
    ' * Build a route path with type-safe parameters',
    ' */',
    'function buildPath<T extends keyof RouteParams>(',
    '  path: T,',
    '  params: RouteParams[T],',
    '  query?: Record<string, string | undefined>',
    '): string {',
    '  let result: string = path;',
    '',
    '  for (const [key, value] of Object.entries(params)) {',
    '    result = result.replace(`:${key}?`, encodeURIComponent(String(value)));',
    '    result = result.replace(`:${key}`, encodeURIComponent(String(value)));',
    '  }',
    '',
    '  // Remove unfilled optional params',
    "  result = result.replace(/\\/:[^/]+\\?/g, '');",
    '',
    '  if (query && Object.keys(query).length > 0) {',
    '    const searchParams = new URLSearchParams();',
    '    for (const [key, value] of Object.entries(query)) {',
    '      if (value !== undefined) {',
    '        searchParams.set(key, value);',
    '      }',
    '    }',
    '    const queryString = searchParams.toString();',
    '    if (queryString) {',
    '      result = `${result}?${queryString}`;',
    '    }',
    '  }',
    '',
    '  return result;',
    '}',
    '',
    '// =============================================================================',
    '// Type-Safe Route Builders',
    '// =============================================================================',
    '',
    'export const routes = {',
  ];

  const nonLayoutRoutes = routes.filter((r) => !r.isLayout);

  for (const route of nonLayoutRoutes) {
    const id = generateRouteFunctionName(route);
    const constId = generateRouteId(route);
    const paramMatches = route.urlPath.match(/:[^/?]+/g);

    if (!paramMatches || paramMatches.length === 0) {
      // No params - simple function
      lines.push(`  ${id}: (query?: Record<string, string | undefined>) => {`);
      lines.push(`    const path = ROUTE_PATHS.${constId};`);
      lines.push('    if (!query || Object.keys(query).length === 0) return path;');
      lines.push('    const searchParams = new URLSearchParams();');
      lines.push('    for (const [key, value] of Object.entries(query)) {');
      lines.push('      if (value !== undefined) searchParams.set(key, value);');
      lines.push('    }');
      lines.push('    return `${path}?${searchParams.toString()}`;');
      lines.push('  },');
    } else {
      // Has params - type-safe builder
      lines.push(`  ${id}: (`);
      lines.push(`    params: RouteParams['${route.urlPath}'],`);
      lines.push('    query?: Record<string, string | undefined>');
      lines.push(`  ) => buildPath('${route.urlPath}', params, query),`);
    }
  }

  lines.push('} as const;');
  lines.push('');

  // Generate lazy components
  lines.push('// =============================================================================');
  lines.push('// Lazy Route Components');
  lines.push('// =============================================================================');
  lines.push('');
  lines.push('export const routeComponents: Record<string, LazyExoticComponent<ComponentType<unknown>>> = {');

  for (const route of nonLayoutRoutes) {
    const id = generateRouteId(route);
    const importPath = getImportPath(route.filePath, rootDir);
    lines.push(`  ${id}: lazy(() => import('${importPath}')),`);
  }

  lines.push('};');
  lines.push('');

  // Generate preload functions
  lines.push('// =============================================================================');
  lines.push('// Route Preloading');
  lines.push('// =============================================================================');
  lines.push('');
  lines.push('export const preloadRoute: Record<string, () => Promise<unknown>> = {');

  for (const route of nonLayoutRoutes) {
    const id = generateRouteId(route);
    const importPath = getImportPath(route.filePath, rootDir);
    lines.push(`  ${id}: () => import('${importPath}'),`);
  }

  lines.push('};');
  lines.push('');

  // Re-export types
  lines.push("export { ROUTE_PATHS } from './types';");
  lines.push("export type { RouteParams, RouteId, RoutePath } from './types';");
  lines.push('');

  return lines.join('\n');
}

/**
 * Generate a camelCase function name from a route
 */
function generateRouteFunctionName(route: DiscoveredRoute): string {
  if (route.urlPath === '/') return 'home';

  return route.urlPath
    .replace(/^\//, '')
    .split('/')
    .map((segment, index) => {
      // Handle dynamic segments
      if (segment.startsWith(':')) {
        const name = segment.slice(1).replace('?', '');
        return index === 0 ? name : capitalize(name);
      }
      // Handle static segments with dashes
      const camelSegment = segment
        .split('-')
        .map((part, i) => (i === 0 ? part : capitalize(part)))
        .join('');
      return index === 0 ? camelSegment : capitalize(camelSegment);
    })
    .join('');
}

/**
 * Get import path relative to src
 */
function getImportPath(filePath: string, rootDir: string): string {
  return filePath
    .replace(rootDir, '')
    .replace(/^[\\/]src[\\/]/, '@/')
    .replace(/\\/g, '/')
    .replace(/\.tsx?$/, '');
}

/**
 * Capitalize first letter
 */
function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

/**
 * Ensure directory exists
 */
async function ensureDir(dir: string): Promise<void> {
  try {
    await mkdir(dir, { recursive: true });
  } catch {
    // Directory may already exist
  }
}

// =============================================================================
// Vite Plugin
// =============================================================================

/**
 * Vite plugin for automatic route discovery and code generation
 */
export function routeDiscoveryPlugin(options: RouteDiscoveryPluginOptions = {}): Plugin {
  const config: DiscoveryConfig = {
    ...DEFAULT_DISCOVERY_CONFIG,
    ...options.config,
  };

  const outputDir = options.outputDir ?? 'src/lib/routing/generated';
  const verbose = options.verbose ?? false;
  const failOnConflict = options.failOnConflict ?? true;
  const watch = options.watch ?? true;
  const generateTypes = options.generateTypes ?? true;
  const generateRegistry = options.generateRegistry ?? true;

  let rootDir: string;
  let server: ViteDevServer | undefined;
  let isGenerating = false;

  function log(message: string): void {
    if (verbose) {
      console.log(`[route-discovery] ${message}`);
    }
  }

  async function generateRoutes(): Promise<void> {
    if (isGenerating) return;
    isGenerating = true;

    const startTime = Date.now();

    try {
      log('Scanning routes...');

      // Scan file system
      const routes = await scanRouteFiles(rootDir, config);

      log(`Found ${routes.length} routes`);

      // Detect conflicts
      const conflicts = detectRouteConflicts(routes);

      if (conflicts.hasErrors) {
        console.error(conflicts.report);
        if (failOnConflict) {
          throw new Error('Route conflicts detected. Build aborted.');
        }
      }

      if (conflicts.hasWarnings) {
        console.warn(conflicts.report);
      }

      // Generate output files
      const outputPath = resolve(rootDir, outputDir);
      await ensureDir(outputPath);

      const generationPromises: Promise<void>[] = [];

      if (generateTypes) {
        const typesContent = generateRouteTypes(routes, rootDir);
        generationPromises.push(
          writeFile(resolve(outputPath, 'types.ts'), typesContent, 'utf-8')
        );
      }

      if (generateRegistry) {
        const registryContent = generateRouteRegistry(routes, rootDir);
        generationPromises.push(
          writeFile(resolve(outputPath, 'routes.ts'), registryContent, 'utf-8')
        );
      }

      // Generate index file
      const indexContent = [
        '/**',
        ' * @file Auto-Generated Route Exports',
        ' * @description DO NOT EDIT - Generated by vite-plugin-routes',
        ` * @generated ${new Date().toISOString()}`,
        ' */',
        '',
        generateTypes ? "export * from './types';" : '',
        generateRegistry ? "export * from './routes';" : '',
        '',
      ]
        .filter(Boolean)
        .join('\n');

      generationPromises.push(
        writeFile(resolve(outputPath, 'index.ts'), indexContent, 'utf-8')
      );

      await Promise.all(generationPromises);

      const duration = Date.now() - startTime;
      log(`Generated route files in ${duration}ms`);
    } catch (error) {
      console.error('[route-discovery] Error generating routes:', error);
      throw error;
    } finally {
      isGenerating = false;
    }
  }

  function isRouteFile(file: string): boolean {
    const watchPaths = config.scanPaths.map((p) => resolve(rootDir, p));

    // Check if file is in a watched directory
    const isInWatchPath = watchPaths.some((p) => file.startsWith(p));
    if (!isInWatchPath) return false;

    // Check file extension
    return config.extensions.some((ext) => file.endsWith(ext));
  }

  return {
    name: 'route-discovery',

    configResolved(resolvedConfig: ResolvedConfig) {
      rootDir = resolvedConfig.root;
    },

    async buildStart() {
      await generateRoutes();
    },

    configureServer(devServer: ViteDevServer) {
      server = devServer;

      if (!watch) return;

      // Watch for route file changes
      devServer.watcher.on('add', async (path: string) => {
        if (isRouteFile(path)) {
          log(`Route file added: ${path}`);
          clearRouteCache();
          await generateRoutes();
          devServer.ws.send({ type: 'full-reload' });
        }
      });

      devServer.watcher.on('unlink', async (path: string) => {
        if (isRouteFile(path)) {
          log(`Route file removed: ${path}`);
          clearRouteCache();
          await generateRoutes();
          devServer.ws.send({ type: 'full-reload' });
        }
      });

      devServer.watcher.on('change', async (path: string) => {
        if (isRouteFile(path)) {
          log(`Route file changed: ${path}`);
          // For changes, we don't regenerate unless exports changed
          // React HMR handles component updates
        }
      });
    },

    async handleHotUpdate({ file }: { file: string }) {
      if (!server) return;

      // Check if a route file was renamed or structure changed
      if (isRouteFile(file)) {
        // Route files get normal HMR treatment
        // Only regenerate on add/remove which is handled by watcher
        return;
      }
    },
  };
}

// =============================================================================
// Dev Server API
// =============================================================================

/**
 * Route inspection API for development
 */
interface RouteInspectionAPI {
  /** Get all discovered routes */
  getRoutes(): DiscoveredRoute[];
  /** Get route by path */
  getRoute(path: string): DiscoveredRoute | undefined;
  /** Get conflict report */
  getConflicts(): ReturnType<typeof detectRouteConflicts>;
  /** Get route statistics */
  getStats(): {
    totalRoutes: number;
    layoutCount: number;
    dynamicRoutes: number;
    maxDepth: number;
  };
  /** Force route regeneration */
  regenerate(): Promise<void>;
  /** Get route tree visualization */
  getRouteTree(): string;
}

/**
 * Create route inspection API for dev server
 */
function createInspectionAPI(
  rootDir: string,
  config: DiscoveryConfig,
  generateRoutes: () => Promise<void>
): RouteInspectionAPI {
  let cachedRoutes: DiscoveredRoute[] = [];

  return {
    getRoutes() {
      return cachedRoutes;
    },

    getRoute(path: string) {
      return cachedRoutes.find((r) => r.urlPath === path);
    },

    getConflicts() {
      return detectRouteConflicts(cachedRoutes);
    },

    getStats() {
      const layouts = cachedRoutes.filter((r) => r.isLayout);
      const dynamicRoutes = cachedRoutes.filter((r) =>
        r.segments.some((s) => s.type === 'dynamic' || s.type === 'catchAll')
      );
      let maxDepth = 0;
      for (const route of cachedRoutes) {
        if (route.depth > maxDepth) maxDepth = route.depth;
      }

      return {
        totalRoutes: cachedRoutes.length,
        layoutCount: layouts.length,
        dynamicRoutes: dynamicRoutes.length,
        maxDepth,
      };
    },

    async regenerate() {
      clearRouteCache();
      await generateRoutes();
      cachedRoutes = await scanRouteFiles(rootDir, config);
    },

    getRouteTree() {
      const lines: string[] = ['Route Tree:', ''];
      const sortedRoutes = [...cachedRoutes].sort((a, b) =>
        a.urlPath.localeCompare(b.urlPath)
      );

      for (const route of sortedRoutes) {
        const indent = '  '.repeat(route.depth);
        const type = route.isLayout ? '[L]' : route.isIndex ? '[I]' : '   ';
        const dynamic = route.segments.some((s) => s.type === 'dynamic')
          ? ' (dynamic)'
          : '';
        lines.push(`${indent}${type} ${route.urlPath}${dynamic}`);
      }

      return lines.join('\n');
    },
  };
}

// =============================================================================
// HMR Support
// =============================================================================

/**
 * Enhanced plugin with HMR support for route files
 */
export function routeDiscoveryPluginWithHMR(
  options: RouteDiscoveryPluginOptions = {}
): Plugin {
  const basePlugin = routeDiscoveryPlugin(options);
  let inspectionAPI: RouteInspectionAPI | null = null;

  return {
    ...basePlugin,
    name: 'route-discovery-hmr',

    configureServer(server: ViteDevServer) {
      // Call base plugin's configureServer if it exists
      if (basePlugin.configureServer) {
        (basePlugin.configureServer as (server: ViteDevServer) => void)(server);
      }

      // Add inspection API endpoint
      server.middlewares.use('/__routes', (req, res) => {
        if (!inspectionAPI) {
          res.statusCode = 503;
          res.end('Route inspection not available');
          return;
        }

        const url = new URL(req.url || '/', 'http://localhost');
        const action = url.searchParams.get('action');

        res.setHeader('Content-Type', 'application/json');

        try {
          switch (action) {
            case 'list':
              res.end(JSON.stringify(inspectionAPI.getRoutes(), null, 2));
              break;
            case 'conflicts':
              res.end(JSON.stringify(inspectionAPI.getConflicts(), null, 2));
              break;
            case 'stats':
              res.end(JSON.stringify(inspectionAPI.getStats(), null, 2));
              break;
            case 'tree':
              res.setHeader('Content-Type', 'text/plain');
              res.end(inspectionAPI.getRouteTree());
              break;
            case 'regenerate':
              inspectionAPI.regenerate().then(() => {
                res.end(JSON.stringify({ success: true }));
              });
              break;
            default:
              res.end(
                JSON.stringify({
                  endpoints: [
                    '?action=list - List all routes',
                    '?action=conflicts - Show route conflicts',
                    '?action=stats - Show route statistics',
                    '?action=tree - Show route tree',
                    '?action=regenerate - Force regeneration',
                  ],
                })
              );
          }
        } catch (error) {
          res.statusCode = 500;
          res.end(JSON.stringify({ error: String(error) }));
        }
      });

      console.log('[route-discovery] Dev inspection available at /__routes');
    },
  };
}

// =============================================================================
// Route Visualization
// =============================================================================

/**
 * Generate a visual route map for documentation
 */
export function generateRouteMap(routes: DiscoveredRoute[]): string {
  const lines: string[] = [
    '# Route Map',
    '',
    '> Auto-generated route documentation',
    '',
    '## Routes',
    '',
    '| Path | Type | Layout | File |',
    '|------|------|--------|------|',
  ];

  const sortedRoutes = [...routes]
    .filter((r) => !r.isLayout)
    .sort((a, b) => a.urlPath.localeCompare(b.urlPath));

  for (const route of sortedRoutes) {
    const type = route.isIndex
      ? 'Index'
      : route.segments.some((s) => s.type === 'dynamic')
        ? 'Dynamic'
        : route.segments.some((s) => s.type === 'catchAll')
          ? 'Catch-all'
          : 'Static';

    const layout = route.parentLayout
      ? route.parentLayout.split('/').pop()?.replace('.tsx', '') || '-'
      : '-';

    const file = route.relativePath;

    lines.push(`| \`${route.urlPath}\` | ${type} | ${layout} | \`${file}\` |`);
  }

  // Add layouts section
  const layouts = routes.filter((r) => r.isLayout);
  if (layouts.length > 0) {
    lines.push('');
    lines.push('## Layouts');
    lines.push('');
    lines.push('| Name | Path | Children |');
    lines.push('|------|------|----------|');

    for (const layout of layouts) {
      const name = layout.relativePath.split('/').slice(-2, -1)[0] || 'root';
      const children = routes.filter(
        (r) => r.parentLayout === layout.filePath
      ).length;
      lines.push(`| ${name} | \`${layout.urlPath}\` | ${children} |`);
    }
  }

  return lines.join('\n');
}

/**
 * Generate route constants file for type-safe navigation
 */
export function generateRouteConstants(
  routes: DiscoveredRoute[],
  rootDir: string
): string {
  const lines: string[] = [
    '/**',
    ' * @file Route Constants',
    ' * @description Auto-generated route path constants for type-safe navigation',
    ` * @generated ${new Date().toISOString()}`,
    ' */',
    '',
    '// Route path constants',
    'export const ROUTES = {',
  ];

  const nonLayoutRoutes = routes.filter((r) => !r.isLayout);

  for (const route of nonLayoutRoutes) {
    const id = generateRouteId(route);
    lines.push(`  /** ${route.urlPath} */`);
    lines.push(`  ${id}: '${route.urlPath}' as const,`);
  }

  lines.push('} as const;');
  lines.push('');
  lines.push('export type RouteName = keyof typeof ROUTES;');
  lines.push('export type RoutePath = typeof ROUTES[RouteName];');
  lines.push('');

  // Generate navigation helpers
  lines.push('// Navigation helper');
  lines.push('export function getRoutePath(name: RouteName): RoutePath {');
  lines.push('  return ROUTES[name];');
  lines.push('}');
  lines.push('');

  return lines.join('\n');
}

// Default export for easier importing
export default routeDiscoveryPlugin;
